(in-package #:lisp-tracer)

(defparameter epsilon 0.00001)

(defun eq? (a b)
  (< (abs (- a b)) epsilon))

(defgeneric add (term1 term2)
  (:documentation "Adding datastructures together")
  (:method ((x number) (y number)) (+ x y))
  (:method ((x tuple) (y tuple))
    (make-tuple
     :x (+ (tuple-x x) (tuple-x y))
     :y (+ (tuple-y x) (tuple-y y))
     :z (+ (tuple-z x) (tuple-z y))
     :w (+ (tuple-w x) (tuple-w y))))
  (:method ((x color) (y color))
    (make-color
     (+ (red x) (red y))
     (+ (green x) (green y))
     (+ (blue x) (blue y)))))

(defgeneric sub (term1 term2)
  (:documentation "Subtracting datastructures")
  (:method ((x number) (y number)) (- x y))
  (:method ((x tuple) (y tuple))
    (make-tuple
     :x (- (tuple-x x) (tuple-x y))
     :y (- (tuple-y x) (tuple-y y))
     :z (- (tuple-z x) (tuple-z y))
     :w (- (tuple-w x) (tuple-w y))))
  (:method ((x color) (y color))
    (make-color
     (- (red x) (red y))
     (- (green x) (green y))
     (- (blue x) (blue y)))))

(defgeneric mult (term1 term2)
  (:documentation "Multiplying datastructures with scalar")
  (:method ((x number) (y number)) (* x y))
  (:method ((x tuple) (y number))
    (make-tuple
     :x (* (tuple-x x) y)
     :y (* (tuple-y x) y)
     :z (* (tuple-z x) y)
     :w (* (tuple-w x) y)))
  (:method ((x color) (y number))
    (make-color
     (* (red x) y)
     (* (green x) y)
     (* (blue x) y)))
  (:method ((x color) (y color))
    (make-color
     (* (red x) (red y))
     (* (green x) (green y))
     (* (blue x) (blue y))))
  (:method ((a matrix) (b matrix))
    (let ((grid-1 (matrix-grid a))
          (grid-2 (matrix-grid b)))
      (create-matrix
       `(,(+ (* (aref grid-1 0 0) (aref grid-2 0 0))
             (* (aref grid-1 0 1) (aref grid-2 1 0))
             (* (aref grid-1 0 2) (aref grid-2 2 0))
             (* (aref grid-1 0 3) (aref grid-2 3 0)))
         ,(+ (* (aref grid-1 0 0) (aref grid-2 0 1))
             (* (aref grid-1 0 1) (aref grid-2 1 1))
             (* (aref grid-1 0 2) (aref grid-2 2 1))
             (* (aref grid-1 0 3) (aref grid-2 3 1)))
         ,(+ (* (aref grid-1 0 0) (aref grid-2 0 2))
             (* (aref grid-1 0 1) (aref grid-2 1 2))
             (* (aref grid-1 0 2) (aref grid-2 2 2))
             (* (aref grid-1 0 3) (aref grid-2 3 2)))
         ,(+ (* (aref grid-1 0 0) (aref grid-2 0 3))
             (* (aref grid-1 0 1) (aref grid-2 1 3))
             (* (aref grid-1 0 2) (aref grid-2 2 3))
             (* (aref grid-1 0 3) (aref grid-2 3 3)))

         ,(+ (* (aref grid-1 1 0) (aref grid-2 0 0))
             (* (aref grid-1 1 1) (aref grid-2 1 0))
             (* (aref grid-1 1 2) (aref grid-2 2 0))
             (* (aref grid-1 1 3) (aref grid-2 3 0)))
         ,(+ (* (aref grid-1 1 0) (aref grid-2 0 1))
             (* (aref grid-1 1 1) (aref grid-2 1 1))
             (* (aref grid-1 1 2) (aref grid-2 2 1))
             (* (aref grid-1 1 3) (aref grid-2 3 1)))
         ,(+ (* (aref grid-1 1 0) (aref grid-2 0 2))
             (* (aref grid-1 1 1) (aref grid-2 1 2))
             (* (aref grid-1 1 2) (aref grid-2 2 2))
             (* (aref grid-1 1 3) (aref grid-2 3 2)))
         ,(+ (* (aref grid-1 1 0) (aref grid-2 0 3))
             (* (aref grid-1 1 1) (aref grid-2 1 3))
             (* (aref grid-1 1 2) (aref grid-2 2 3))
             (* (aref grid-1 1 3) (aref grid-2 3 3)))

         ,(+ (* (aref grid-1 2 0) (aref grid-2 0 0))
             (* (aref grid-1 2 1) (aref grid-2 1 0))
             (* (aref grid-1 2 2) (aref grid-2 2 0))
             (* (aref grid-1 2 3) (aref grid-2 3 0)))
         ,(+ (* (aref grid-1 2 0) (aref grid-2 0 1))
             (* (aref grid-1 2 1) (aref grid-2 1 1))
             (* (aref grid-1 2 2) (aref grid-2 2 1))
             (* (aref grid-1 2 3) (aref grid-2 3 1)))
         ,(+ (* (aref grid-1 2 0) (aref grid-2 0 2))
             (* (aref grid-1 2 1) (aref grid-2 1 2))
             (* (aref grid-1 2 2) (aref grid-2 2 2))
             (* (aref grid-1 2 3) (aref grid-2 3 2)))
         ,(+ (* (aref grid-1 2 0) (aref grid-2 0 3))
             (* (aref grid-1 2 1) (aref grid-2 1 3))
             (* (aref grid-1 2 2) (aref grid-2 2 3))
             (* (aref grid-1 2 3) (aref grid-2 3 3)))

         ,(+ (* (aref grid-1 3 0) (aref grid-2 0 0))
             (* (aref grid-1 3 1) (aref grid-2 1 0))
             (* (aref grid-1 3 2) (aref grid-2 2 0))
             (* (aref grid-1 3 3) (aref grid-2 3 0)))
         ,(+ (* (aref grid-1 3 0) (aref grid-2 0 1))
             (* (aref grid-1 3 1) (aref grid-2 1 1))
             (* (aref grid-1 3 2) (aref grid-2 2 1))
             (* (aref grid-1 3 3) (aref grid-2 3 1)))
         ,(+ (* (aref grid-1 3 0) (aref grid-2 0 2))
             (* (aref grid-1 3 1) (aref grid-2 1 2))
             (* (aref grid-1 3 2) (aref grid-2 2 2))
             (* (aref grid-1 3 3) (aref grid-2 3 2)))
         ,(+ (* (aref grid-1 3 0) (aref grid-2 0 3))
             (* (aref grid-1 3 1) (aref grid-2 1 3))
             (* (aref grid-1 3 2) (aref grid-2 2 3))
             (* (aref grid-1 3 3) (aref grid-2 3 3)))))))
  (:method ((a matrix) (b tuple))
    (let ((h (tuple-x b))
          (j (tuple-y b))
          (k (tuple-z b))
          (l (tuple-w b))
          (grid (matrix-grid a)))
      (make-tuple
       :x (+ (* (aref grid 0 0) h)
             (* (aref grid 0 1) j)
             (* (aref grid 0 2) k)
             (* (aref grid 0 3) l))
       :y (+ (* (aref grid 1 0) h)
             (* (aref grid 1 1) j)
             (* (aref grid 1 2) k)
             (* (aref grid 1 3) l))
       :z (+ (* (aref grid 2 0) h)
             (* (aref grid 2 1) j)
             (* (aref grid 2 2) k)
             (* (aref grid 2 3) l))
       :w (+ (* (aref grid 3 0) h)
             (* (aref grid 3 1) j)
             (* (aref grid 3 2) k)
             (* (aref grid 3 3) l))))))

(defgeneric div (term1 term2)
  (:documentation "Dividing datastructures with scalar")
  (:method ((x number) (y number)) (float (/ x y)))
  (:method ((x tuple) (y number))
    (make-tuple
     :x (float (/ (tuple-x x) y))
     :y (float (/ (tuple-y x) y))
     :z (float (/ (tuple-z x) y))
     :w (float (/ (tuple-w x) y)))))

(defgeneric equal? (a b)
  (:documentation "Checking for unsafe equality")
  (:method ((a number) (b number)) (eq? a b))
  (:method ((x tuple) (y tuple))
    (and (eq? (tuple-x x) (tuple-x y))
         (eq? (tuple-y x) (tuple-y y))
         (eq? (tuple-z x) (tuple-z y))
         (eq? (tuple-w x) (tuple-w y))))
  (:method ((x color) (y color))
    (and (eq? (red x) (red y))
         (eq? (green x) (green y))
         (eq? (blue x) (blue y))))
  (:method ((x matrix) (y matrix))
    (iter (for i below 4)
      (always
       (iter (for j below 4)
         (always
          (eq? (m x i j) (m y i j)))))))
  (:method ((x material) (y material))
    (and (equal? (material-color x) (material-color y))
         (eq? (ambient x) (ambient y))
         (eq? (diffuse x) (diffuse y))
         (eq? (specular x) (specular y))
         (eq? (shininess x) (shininess y)))))

(defgeneric neg (element)
  (:documentation "Negates provided value")
  (:method ((x number)) (- x))
  (:method ((tup tuple))
    (make-tuple
     :x (- (tuple-x tup))
     :y (- (tuple-y tup))
     :z (- (tuple-z tup))
     :w (- (tuple-w tup)))))

(defun magnitude (vec)
  (let ((a (tuple-x vec))
        (b (tuple-y vec))
        (c (tuple-z vec))
        (d (tuple-w vec)))
    (sqrt
     (+ (* a a)
        (* b b)
        (* c c)
        (* d d)))))

(defun normalize (vec)
  (make-tuple
   :x (/ (tuple-x vec) (magnitude vec))
   :y (/ (tuple-y vec) (magnitude vec))
   :z (/ (tuple-z vec) (magnitude vec))
   :w (/ (tuple-w vec) (magnitude vec))))

(defun dot (a b)
  (+ (* (tuple-x a) (tuple-x b))
     (* (tuple-y a) (tuple-y b))
     (* (tuple-z a) (tuple-z b))
     (* (tuple-w a) (tuple-w b))))

(defun cross (tuple-a tuple-b)
  (let ((a (tuple-x tuple-a))
        (b (tuple-y tuple-a))
        (c (tuple-z tuple-a))

        (d (tuple-x tuple-b))
        (e (tuple-y tuple-b))
        (f (tuple-z tuple-b)))
    (make-vec
     (- (* b f)
        (* c e))
     (- (* c d)
        (* a f))
     (- (* a e)
        (* b d)))))
