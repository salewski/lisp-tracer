(in-package #:lisp-tracer)

(defparameter epsilon 0.00001)

(defun eq? (a b)
  (< (abs (- a b)) epsilon))

(defgeneric add (term1 term2)
  (:documentation "Adding datastructures together")
  (:method ((x number) (y number)) (+ x y))
  (:method ((x tuple) (y tuple))
    (make-tuple
     (+ (x x) (x y))
     (+ (y x) (y y))
     (+ (z x) (z y))
     (+ (w x) (w y))))
  (:method ((x color) (y color))
    (make-color
     (+ (red x) (red y))
     (+ (green x) (green y))
     (+ (blue x) (blue y)))))

(defgeneric sub (term1 term2)
  (:documentation "Subtracting datastructures")
  (:method ((x number) (y number)) (- x y))
  (:method ((x tuple) (y tuple))
    (make-tuple
     (- (x x) (x y))
     (- (y x) (y y))
     (- (z x) (z y))
     (- (w x) (w y))))
  (:method ((x color) (y color))
    (make-color
     (- (red x) (red y))
     (- (green x) (green y))
     (- (blue x) (blue y)))))

(defgeneric mult (term1 term2)
  (:documentation "Multiplying datastructures with scalar")
  (:method ((x number) (y number)) (* x y))
  (:method ((x tuple) (y number))
    (make-tuple
     (* (x x) y)
     (* (y x) y)
     (* (z x) y)
     (* (w x) y)))
  (:method ((x color) (y number))
    (make-color
     (* (red x) y)
     (* (green x) y)
     (* (blue x) y)))
  (:method ((x color) (y color))
    (make-color
     (* (red x) (red y))
     (* (green x) (green y))
     (* (blue x) (blue y))))
  (:method ((a matrix) (b matrix))
    (let ((size (dimensions a))
          (grid-1 (grid a))
          (grid-2 (grid b)))
      (make-matrix
       size
       `(,(+ (* (aref grid-1 0 0) (aref grid-2 0 0))
             (* (aref grid-1 0 1) (aref grid-2 1 0))
             (* (aref grid-1 0 2) (aref grid-2 2 0))
             (* (aref grid-1 0 3) (aref grid-2 3 0)))
         ,(+ (* (aref grid-1 0 0) (aref grid-2 0 1))
             (* (aref grid-1 0 1) (aref grid-2 1 1))
             (* (aref grid-1 0 2) (aref grid-2 2 1))
             (* (aref grid-1 0 3) (aref grid-2 3 1)))
         ,(+ (* (aref grid-1 0 0) (aref grid-2 0 2))
             (* (aref grid-1 0 1) (aref grid-2 1 2))
             (* (aref grid-1 0 2) (aref grid-2 2 2))
             (* (aref grid-1 0 3) (aref grid-2 3 2)))
         ,(+ (* (aref grid-1 0 0) (aref grid-2 0 3))
             (* (aref grid-1 0 1) (aref grid-2 1 3))
             (* (aref grid-1 0 2) (aref grid-2 2 3))
             (* (aref grid-1 0 3) (aref grid-2 3 3)))

         ,(+ (* (aref grid-1 1 0) (aref grid-2 0 0))
             (* (aref grid-1 1 1) (aref grid-2 1 0))
             (* (aref grid-1 1 2) (aref grid-2 2 0))
             (* (aref grid-1 1 3) (aref grid-2 3 0)))
         ,(+ (* (aref grid-1 1 0) (aref grid-2 0 1))
             (* (aref grid-1 1 1) (aref grid-2 1 1))
             (* (aref grid-1 1 2) (aref grid-2 2 1))
             (* (aref grid-1 1 3) (aref grid-2 3 1)))
         ,(+ (* (aref grid-1 1 0) (aref grid-2 0 2))
             (* (aref grid-1 1 1) (aref grid-2 1 2))
             (* (aref grid-1 1 2) (aref grid-2 2 2))
             (* (aref grid-1 1 3) (aref grid-2 3 2)))
         ,(+ (* (aref grid-1 1 0) (aref grid-2 0 3))
             (* (aref grid-1 1 1) (aref grid-2 1 3))
             (* (aref grid-1 1 2) (aref grid-2 2 3))
             (* (aref grid-1 1 3) (aref grid-2 3 3)))

         ,(+ (* (aref grid-1 2 0) (aref grid-2 0 0))
             (* (aref grid-1 2 1) (aref grid-2 1 0))
             (* (aref grid-1 2 2) (aref grid-2 2 0))
             (* (aref grid-1 2 3) (aref grid-2 3 0)))
         ,(+ (* (aref grid-1 2 0) (aref grid-2 0 1))
             (* (aref grid-1 2 1) (aref grid-2 1 1))
             (* (aref grid-1 2 2) (aref grid-2 2 1))
             (* (aref grid-1 2 3) (aref grid-2 3 1)))
         ,(+ (* (aref grid-1 2 0) (aref grid-2 0 2))
             (* (aref grid-1 2 1) (aref grid-2 1 2))
             (* (aref grid-1 2 2) (aref grid-2 2 2))
             (* (aref grid-1 2 3) (aref grid-2 3 2)))
         ,(+ (* (aref grid-1 2 0) (aref grid-2 0 3))
             (* (aref grid-1 2 1) (aref grid-2 1 3))
             (* (aref grid-1 2 2) (aref grid-2 2 3))
             (* (aref grid-1 2 3) (aref grid-2 3 3)))

         ,(+ (* (aref grid-1 3 0) (aref grid-2 0 0))
             (* (aref grid-1 3 1) (aref grid-2 1 0))
             (* (aref grid-1 3 2) (aref grid-2 2 0))
             (* (aref grid-1 3 3) (aref grid-2 3 0)))
         ,(+ (* (aref grid-1 3 0) (aref grid-2 0 1))
             (* (aref grid-1 3 1) (aref grid-2 1 1))
             (* (aref grid-1 3 2) (aref grid-2 2 1))
             (* (aref grid-1 3 3) (aref grid-2 3 1)))
         ,(+ (* (aref grid-1 3 0) (aref grid-2 0 2))
             (* (aref grid-1 3 1) (aref grid-2 1 2))
             (* (aref grid-1 3 2) (aref grid-2 2 2))
             (* (aref grid-1 3 3) (aref grid-2 3 2)))
         ,(+ (* (aref grid-1 3 0) (aref grid-2 0 3))
             (* (aref grid-1 3 1) (aref grid-2 1 3))
             (* (aref grid-1 3 2) (aref grid-2 2 3))
             (* (aref grid-1 3 3) (aref grid-2 3 3)))))))
  (:method ((a matrix) (b tuple))
    (let ((h (x b))
          (j (y b))
          (k (z b))
          (l (w b))
          (grid (grid a)))
      (make-tuple
       (+ (* (aref grid 0 0) h)
          (* (aref grid 0 1) j)
          (* (aref grid 0 2) k)
          (* (aref grid 0 3) l))
       (+ (* (aref grid 1 0) h)
          (* (aref grid 1 1) j)
          (* (aref grid 1 2) k)
          (* (aref grid 1 3) l))
       (+ (* (aref grid 2 0) h)
          (* (aref grid 2 1) j)
          (* (aref grid 2 2) k)
          (* (aref grid 2 3) l))
       (+ (* (aref grid 3 0) h)
          (* (aref grid 3 1) j)
          (* (aref grid 3 2) k)
          (* (aref grid 3 3) l))))))

(defgeneric div (term1 term2)
  (:documentation "Dividing datastructures with scalar")
  (:method ((x number) (y number)) (float (/ x y)))
  (:method ((x tuple) (y number))
    (->> (mapnumber #'/ x y)
         (map 'list #'float)
         (apply #'make-tuple))))

(defgeneric equal? (a b)
  (:documentation "Checking for unsafe equality")
  (:method ((a number) (b number)) (eq? a b))
  (:method ((x tuple) (y tuple))
    (and (eq? (x x) (x y))
         (eq? (y x) (y y))
         (eq? (z x) (z y))
         (eq? (w x) (w y))))
  (:method ((x color) (y color))
    (and (eq? (red x) (red y))
         (eq? (green x) (green y))
         (eq? (blue x) (blue y))))
  (:method ((x matrix) (y matrix))
    (iter (for i below (dimensions x))
      (always
       (iter (for j below (dimensions x))
         (always
          (eq? (m x i j) (m y i j)))))))
  (:method ((x material) (y material))
    (and (equal? (material-color x) (material-color y))
         (eq? (ambient x) (ambient y))
         (eq? (diffuse x) (diffuse y))
         (eq? (specular x) (specular y))
         (eq? (shininess x) (shininess y)))))

(defgeneric neg (element)
  (:documentation "Negates provided value")
  (:method ((x number)) (- x))
  (:method ((tup tuple))
    (make-tuple (- (x tup))
                (- (y tup))
                (- (z tup))
                (- (w tup)))))

(defun magnitude (vec)
  (let ((a (x vec))
        (b (y vec))
        (c (z vec))
        (d (w vec)))
    (sqrt
     (+ (* a a)
        (* b b)
        (* c c)
        (* d d)))))

(defun normalize (vec)
  (make-tuple
   (/ (x vec) (magnitude vec))
   (/ (y vec) (magnitude vec))
   (/ (z vec) (magnitude vec))
   (/ (w vec) (magnitude vec))))

(defun dot (a b)
  (+ (* (x a) (x b))
     (* (y a) (y b))
     (* (z a) (z b))
     (* (w a) (w b))))

(defun cross (tuple-a tuple-b)
  (let ((a (x tuple-a))
        (b (y tuple-a))
        (c (z tuple-a))

        (d (x tuple-b))
        (e (y tuple-b))
        (f (z tuple-b)))
    (make-vec
     (- (* b f)
        (* c e))
     (- (* c d)
        (* a f))
     (- (* a e)
        (* b d)))))
