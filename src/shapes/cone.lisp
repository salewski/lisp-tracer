(in-package #:lisp-tracer)

(defstruct (cone (:include shape))
  (closed nil :type t)
  (minimum sb-ext:double-float-negative-infinity :type double-float)
  (maximum sb-ext:double-float-positive-infinity :type double-float))

(declaim (inline check-cone-cap))
(defun check-cone-cap (ray tt r)
  (let ((x (+ (ray-origin-x ray) (* tt (ray-direction-x ray))))
        (z (+ (ray-origin-z ray) (* tt (ray-direction-z ray)))))
    (<= (+ (expt x 2) (expt z 2)) (expt r 2))))

(defmethod local-intersect ((cone cone) (ray ray))
  (append (intersect-cone cone ray)
          (intersect-cone-caps cone ray)))

(defun intersect-cone (cone ray)
  (let* ((a (+ (- (expt (ray-direction-x ray) 2)
                  (expt (ray-direction-y ray) 2))
               (expt (ray-direction-z ray) 2)))
         (b (+ (- (* 2.0 (ray-origin-x ray) (ray-direction-x ray))
                  (* 2.0 (ray-origin-y ray) (ray-direction-y ray)))
               (* 2.0 (ray-origin-z ray) (ray-direction-z ray))))
         (c (+ (- (expt (ray-origin-x ray) 2)
                  (expt (ray-origin-y ray) 2))
               (expt (ray-origin-z ray) 2))))
    (unless (and (equal? a 0.0) (equal? b 0.0))
        (if (equal? a 0.0)
            (list (make-intersection :tt (/ (- c) (* 2.0 b)) :object cone))
            (let* ((discriminant (- (expt b 2) (* 4.0 a c))))
              (unless (< discriminant 0)
                (let* ((-b (- b))
                       (sqrt-discriminant (sqrt discriminant))
                       (2a (* 2.0 a))
                       (t0 (/ (- -b sqrt-discriminant) 2a))
                       (t1 (/ (+ -b sqrt-discriminant) 2a)))
                  (if (> t0 t1) (rotatef t0 t1))
                  (let* ((y0 (+ (ray-origin-y ray) (* t0 (ray-direction-y ray))))
                         (y1 (+ (ray-origin-y ray) (* t0 (ray-direction-y ray))))
                         (first-intersection
                           (if (< (cone-minimum cone) y0 (cone-maximum cone))
                               (list (make-intersection :tt t0 :object cone))))
                         (second-intersection
                           (if (< (cone-minimum cone) y1 (cone-maximum cone))
                               (list (make-intersection :tt t1 :object cone)))))
                    (append first-intersection second-intersection)))))))))

(defun intersect-cone-caps (cone ray)
  (unless (or (not (cone-closed cone)) (equal? (ray-direction-y ray) 0.0))
    (labels ((t-value (min-or-max)
               (/ (- min-or-max (ray-origin-y ray))
                  (ray-direction-y ray))))
      (let* ((t1 (t-value (cone-minimum cone)))
             (t2 (t-value (cone-maximum cone)))
             (first-intersection
               (when (check-cone-cap ray t1 (cone-minimum cone))
                 (list (make-intersection :tt t1 :object cone))))
             (second-intersection
               (when (check-cone-cap ray t2 (cone-maximum cone))
                 (list (make-intersection :tt t2 :object cone)))))
        (append first-intersection second-intersection)))))

  
(defmethod local-normal-at ((cone cone) (point tuple))
  (let ((distance (+ (expt (tuple-x point) 2) (expt (tuple-z point) 2))))
    (cond ((and (< distance 1.0)
                (>= (tuple-y point) (- (cone-maximum cone) epsilon)))
           (make-vec :x 0.0 :y 1.0 :z 0.0))
          ((and (< distance 1.0)
                (<= (tuple-y point) (+ (cone-minimum cone) epsilon)))
           (make-vec :x 0.0 :y -1.0 :z 0.0))
          (t (let* ((y (sqrt distance)))
               (make-vec :x (tuple-x point)
                         :y (if (> (tuple-y point) 0)
                                (- y)
                                y)
                         :z (tuple-z point)))))))
